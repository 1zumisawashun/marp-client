---
marp: true
theme: lt
headingDivider: 1 # ページ切り替えの基準を見出し1にする
paginate: true # ページを下部に表示する
size: 16:9 # 縦横比の設定をする、4:3か16:9が多い
math: katex # Latexを書けるよう設定
---

# インターンシップ発表会（泉澤俊）

2025/09/12

# アジェンダ

- プロジェクトの概要と目的
- 技術選定
- 実装で気をつけたこと
  - モデリング
  - ディレクトリ構成
- 1.1実装の紹介
  - CSV to JSON
  - 2n vs n2乗
- 今後の展望

# プロジェクトの概要と目的

〇〇の開発に着手しました。
1-3まで完了しています
メインはバックエンドの開発について取り上げます

# 技術選定

代替案と比較について触れていきます

# TypeScript

- 知見の活用
  - フロントエンドでTypeScriptに慣れていたため学習コストをかけずに開発に取り組むため
- 開発体験の一貫性
  - フロントエンドがsample-app（React, TypeScript）だったので思考の切り替えが少なくなり開発速度が上がるため


hint! -> VSCode（既に拡張機能が入っていて開発体験が良いのでVSCodeで開発できるものを選定したかった）

# Hono

比較対象: Express.js, Nest.js

Express.jsよりもTypeScriptとの親和性が高く、Nest.jsよりも学習コストが低く、シンプルで高性能なHonoを採用しました


# Prisma

比較対象: TypeORM, Drizzle

TypeORMよりも型安全性が高く、Drizzleよりもドキュメントやツール（ex: Prisma Studio）が充実しているため採用しました。

---

prisma studioを差し込む、今回database client入れていたけどの件も話す

# SQLite

比較対象: MySQL, PostgreSQL

今回は作るだけという目的が明確だったため、本番環境でのスケーラビリティや複雑な機能を必要としないのでSQLiteが手軽さと開発効率の観点から採用しました

# POINT

技術選定は目的によって変わる

# 実装


# モデリング

ツールとしてはMiroを使った。エンティティをグループ化し関連をつける作業は何回か往復した。一発でモデリングは完成しなかった。

- Miroなどでエンティティや関係性をグループ化・整理
- ER図やクラス図に落とし込む
- 実際のスキーマや型定義に反映する

---

[1回目]エンティティの整理

![w:500](../assets/images/20250912/1.png)


---

[1回目]関連付け

![w:500](../assets/images/20250912/2.png)

---

[1回目]ER図の作成
実装を進めて予実のテーブルを作る必要に気づいて修正

![w:600](../assets/images/20250912/3.svg)

---

最終的にはこちらで実装

![w:600](../assets/images/20250912/4.svg)

# POINT

割と実装に入ってからモデリングが足りないことに気づき、後戻りする場面もありましたが、早い段階で気づけたことで大きな手戻りにはならずに済みました。

# ディレクトリ構成

コードの見通しをよくするために、3層アーキテクチャ（プレゼンテーション層、ビジネスロジック層、データアクセス層）を意識し、ドメイン駆動設計（DDD）の考え方を参考にディレクトリを分割しました。これにより、役割ごとに責任が明確になり、保守性や拡張性が高まりました。


# 具体例

presentation: プレゼンテーション層
application: ビジネスロジック層
domain: ビジネスロジック層
infrastructure: データアクセス層

※DDDの文脈で4階層に分けているものの実際はdomainは未使用

![bg left:40% 80%](../assets/images/20250912/5.png)


# 1-1の紹介

# CSV to JSON


CSVファイルを自力でパースする際は、落とし穴が多い

- カンマや改行
  - CSVは「,」で区切られたデータ形式ですが、データ自体にカンマや改行が含まれている場合がある
- クォーテーション
  - 
- 文字エンコーディング
  -
- ヘッダーの有無


# POINT

自力でパースする場合は多くのエッジケースを考慮する必要があり、非常に多くの時間と労力がかかる

ライブラリを使おう！

# Papaparse

比較対象: react-papaperse

Reactとの依存関係を減らしバンドルサイズを軽くするため。純粋なCSV to JSONのparseのために利用したくコアライブラリを採用しました。


# O(N)からO(1)にする

計算量を意識して、処理の効率化（O(N)→O(1)）を行った

1-1のテストを通すために、データ構造を[CareReceiver[Service[Plan, Results]]]の形にする必要がありました。  
最初はループ処理が複雑になりがちでしたが、Mapを活用して効率的にデータを集約することで、計算量をO(N)からO(1)に改善できました。  
このような実装の際は、ループやネストが増えて複雑になっていないか、都度見直すことが重要だと


---

```ts
export const createImportCommandBad1 = (
  data: ServicePlanCsvImport[],
): CreateImportCommand[] => {
  const results: CreateImportCommand[] = [];

  // 利用者ごとに処理（毎回全データをfilter）
  data.forEach(d => {
    const careReceiverData = data.filter(item => 
      item.careReceiverFullName === d.careReceiverFullName
    );
    
    // サービスごとに処理（また全データをfilter）
    careReceiverData.forEach(cd => {
      const serviceData = careReceiverData.filter(item => 
        item.serviceName === cd.serviceName
      );
      
      // 重複チェックも毎回全配列を検索
      const exists = results.some(r => 
        r.careReceiverFullName === cd.careReceiverFullName && 
        r.serviceName === cd.serviceName
      );
      
      if (!exists) {
        const { dailyPlan, dailyResult } = getDailyPlansAndResults({
          serviceYearMonth: cd.serviceYearMonth,
          dateMap: new Map(serviceData.map(s => [s.serviceDate, { count: s.serviceCount, date: s.serviceDate }]))
        });
        
        results.push({ ...cd, dailyPlan, dailyResult });
      }
    });
  });

  return results;
};
```

---

```ts
export const createImportCommand = (
  data: ServicePlanCsvImport[],
): CreateImportCommand[] => {
  const careReceiverMap: CareReceiverMap = new Map();

  for (const d of data) {
    const { serviceName, serviceCount, serviceDate, careReceiverFullName } = d;

    // NOTE: careReceiverMapに利用者名が存在しない場合は新規作成する
    if (!careReceiverMap.has(careReceiverFullName)) {
      careReceiverMap.set(careReceiverFullName, new Map());
    }

    const _careReceiverMap = careReceiverMap.get(careReceiverFullName);
    if (!_careReceiverMap) throw new Error("care receiver map not found");

    // NOTE: serviceMapにサービス名が存在しない場合は新規作成する
    if (!_careReceiverMap.has(serviceName)) {
      _careReceiverMap.set(serviceName, { ...d, dateMap: new Map() });
    }
    const _serviceMap = _careReceiverMap.get(serviceName);
    if (!_serviceMap) throw new Error("service map not found");

    _serviceMap.dateMap.set(serviceDate, {
      count: serviceCount,
      date: serviceDate,
    });
  }

  const results = Array.from(careReceiverMap, ([_, serviceMap]) => {
    return Array.from(
      serviceMap,
      ([_, { serviceYearMonth, dateMap, ...rest }]) => {
        const { dailyPlan, dailyResult } = getDailyPlansAndResults({
          serviceYearMonth,
          dateMap,
        });

        return { serviceYearMonth, dailyPlan, dailyResult, ...rest };
      },
    );
  });

  return results.flat(2); // 2次元配列を1次元に変換する
};
```

# 今後の展望

- zodを用いたバックエンドバリデーションの実装
- テスト実装


# ご清聴ありがとうございました！
