---
marp: true
theme: lt
headingDivider: 1 # ページ切り替えの基準を見出し1にする
paginate: true # ページを下部に表示する
size: 16:9 # 縦横比の設定をする、4:3か16:9が多い
math: katex # Latexを書けるよう設定
---

# インターンシップ発表会（泉澤俊）

2025/09/12

# アジェンダ

<div class="flex fw">
<div style="--fw: 3;">

- プロジェクトの概要と目的
- 技術選定
- 実装で気をつけたこと
  - モデリング
  - ディレクトリ構成


</div>
<div style="--fw: 2;">

- 実装内容の紹介
  - CSV to JSON
  - 2n vs n2乗
- 今後の展望
</div>
</div>

# はじめに

〇〇の開発に着手しました。
1-3まで完了しています
メインはバックエンドの開発について取り上げます

# 技術選定

代替案と比較について触れていきます

# TypeScript

- 知見の活用
  - フロントエンドでTypeScriptに慣れていたため学習コストをかけずに開発に取り組むため
- 開発体験の一貫性
  - フロントエンドがsample-app（React, TypeScript）だったので思考の切り替えが少なくなり開発速度が上がるため


hint! -> VSCode（既に拡張機能が入っていて開発体験が良いのでVSCodeで開発できるものを選定したかった）

# Hono

比較対象: Express.js, Nest.js

Express.jsよりもTypeScriptとの親和性が高く、Nest.jsよりも学習コストが低く、シンプルで高性能なHonoを採用しました


# Prisma

比較対象: TypeORM, Drizzle

TypeORMよりも型安全性が高く、Drizzleよりもドキュメントやツール（ex: Prisma Studio）が充実しているため採用しました。

---

prisma studioを差し込む、今回database client入れていたけどの件も話す

# SQLite

比較対象: MySQL, PostgreSQL

今回は作るだけという目的が明確だったため、本番環境でのスケーラビリティや複雑な機能を必要としないのでSQLiteが手軽さと開発効率の観点から採用しました

# POINT

技術選定は目的によって変わる

# 実装


# モデリング



- モデリングの概念は知っていたものの

---

![w:500](../assets/images/20250912/1.png)


---

![bg cover](../assets/images/20250912/2.png)

---

![w:600](../assets/images/20250912/3.svg)

---

![w:600](../assets/images/20250912/4.svg)

# POINT

割と実装に入ってから考慮が足りずに後戻りした

# ディレクトリ構成

コードの見通しをよくするために
プレゼンテーション層、ビジネスロジック層、データアクセス層

# 依存性の注入

これなしにするかあ


# 1-1の紹介

# CSV to JSON


CSVファイルを自力でパースする際は、落とし穴が多い

- カンマや改行
  - CSVは「,」で区切られたデータ形式ですが、データ自体にカンマや改行が含まれている場合がある
- クォーテーション
  - 
- 文字エンコーディング
  -
- ヘッダーの有無

---

自力でパースする場合は多くのエッジケースを考慮する必要があり、非常に多くの時間と労力がかかる

ライブラリを使おう！

---

# Papaparse

比較対象: react-papaperse

Reactとの依存関係を減らしバンドルサイズを軽くするため。純粋なCSV to JSONのparseのために利用したくコアライブラリを採用しました。


# O(N)からO(1)にする

1-1のテストを通すために[CareReceiver[Service[Plan, Results]]]の構造にする必要があった。その際の


---
```
export const createImportCommandBad1 = (
  data: ServicePlanCsvImport[],
): CreateImportCommand[] => {
  const results: CreateImportCommand[] = [];

  // 利用者ごとに処理（毎回全データをfilter）
  data.forEach(d => {
    const careReceiverData = data.filter(item => 
      item.careReceiverFullName === d.careReceiverFullName
    );
    
    // サービスごとに処理（また全データをfilter）
    careReceiverData.forEach(cd => {
      const serviceData = careReceiverData.filter(item => 
        item.serviceName === cd.serviceName
      );
      
      // 重複チェックも毎回全配列を検索
      const exists = results.some(r => 
        r.careReceiverFullName === cd.careReceiverFullName && 
        r.serviceName === cd.serviceName
      );
      
      if (!exists) {
        const { dailyPlan, dailyResult } = getDailyPlansAndResults({
          serviceYearMonth: cd.serviceYearMonth,
          dateMap: new Map(serviceData.map(s => [s.serviceDate, { count: s.serviceCount, date: s.serviceDate }]))
        });
        
        results.push({ ...cd, dailyPlan, dailyResult });
      }
    });
  });

  return results;
};
```

---

```
export const createImportCommand = (
  data: ServicePlanCsvImport[],
): CreateImportCommand[] => {
  const careReceiverMap: CareReceiverMap = new Map();

  for (const d of data) {
    const { serviceName, serviceCount, serviceDate, careReceiverFullName } = d;

    // NOTE: careReceiverMapに利用者名が存在しない場合は新規作成する
    if (!careReceiverMap.has(careReceiverFullName)) {
      careReceiverMap.set(careReceiverFullName, new Map());
    }

    const _careReceiverMap = careReceiverMap.get(careReceiverFullName);
    if (!_careReceiverMap) throw new Error("care receiver map not found");

    // NOTE: serviceMapにサービス名が存在しない場合は新規作成する
    if (!_careReceiverMap.has(serviceName)) {
      _careReceiverMap.set(serviceName, { ...d, dateMap: new Map() });
    }
    const _serviceMap = _careReceiverMap.get(serviceName);
    if (!_serviceMap) throw new Error("service map not found");

    _serviceMap.dateMap.set(serviceDate, {
      count: serviceCount,
      date: serviceDate,
    });
  }

  const results = Array.from(careReceiverMap, ([_, serviceMap]) => {
    return Array.from(
      serviceMap,
      ([_, { serviceYearMonth, dateMap, ...rest }]) => {
        const { dailyPlan, dailyResult } = getDailyPlansAndResults({
          serviceYearMonth,
          dateMap,
        });

        return { serviceYearMonth, dailyPlan, dailyResult, ...rest };
      },
    );
  });

  return results.flat(2); // 2次元配列を1次元に変換する
};
```

# 今後の展望

- zodを用いたバックエンドバリデーションの実装
- テスト実装


# ご清聴ありがとうございました！
